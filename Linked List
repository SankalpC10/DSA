Linked List is a list of chained nodes. Each node has data and a pointer which point towards next node.
struct Node
{
   int data;
   Node *next;
}


1. Display Linked List
   As vector is initialised in function, first create a vector with int type. As we don't need to modify the elements of linked list, create a new temporary node.
   Node should have data of head.We will initialize pointer while loop function. Using while loop, traverse till temp!=NULL.
   In while loop - insert the data of first node in vector and point the location to next element from linked list. Then return vector.
Code:
   vector<int> displayList(Node *head)
  {
    vector<int>v;
    Node*temp=head;
    while(temp!=NULL)
    {
        v.push_back(temp->data);
        temp=temp->next;
    }
    return v;
  }
  
2. Sum The Nodes of Linked List
  Here,we need to return an int data type. So,we begin with creating an int variable.
  Then create a temporrary node which points at head. Start traversing till temp!=NULL,
  while adding each data of temp to sum. Move temp pointer to next element. Return sum. 
Code:
   int sumOfElements(Node *head)
   {
      int sum=0;
      Node *temp=head;
      while(temp!=NULL)
      {
          sum+=temp->data;
          temp=temp->next;
      }
      return sum;
   }
   
3.Count nodes of linked list
   Keep a variable count and keep incrementing it by 1 till we reach last node of linked list.
  Code:
      int getCount(struct Node* head){
        int count=0;
        Node *temp=head;
        while(temp!=NULL)
        {
            count++;
            temp=temp->next;
        }
        return count;
      }
    
 4.Maximum and Minimum in Linked List
   The code is divided into two functions. The first returns maximum and second, the minimum.
   Initialize the variable max as INT_MIN and while traversing check if elements in linked list are greater than our variable.
   If greater,update our variable with greater value from LL.
   Similarly, initialize variable min as INT_Max and keep updating value if we find any smaller element in LL.
   Code:
      int maximum(Node *head)
     {
       int max=INT_MIN;
       Node *temp=head;
       while (temp!=NULL)
       {
           if(temp->data>max)
           {
               max=temp->data;
           }
           temp=temp->next;
       }
       return max;
     }
     int minimum(Node *head)
     {
       int min=INT_MAX;
       Node *temp=head;
       while (temp!=NULL)
       {
           if(temp->data<min)
           {
               min=temp->data;
           }
           temp=temp->next;
       }
       return min;
      }
      
5.Search in a LL
   The function type is boolean, so we make default return type as 0,if we are unable to find required eleent x in our LL.
   Initialize temp node and traverse till end of LL. Return 1 if we find required element.
  Code:
      bool searchLinkedList(Node *head, int x)
      {
          Node *temp=head;
          while(temp!=NULL)
          {
              if(temp->data==x)
              {
                  return 1;
              }
              temp=temp->next;
          }
          return 0;
      }
      
6.Linked List Insertion
   The problem is divide into two parts, insert at beginning and insert at the end.
   Insert in beginning is easier as we just need to create a new node temp containing value of x using struct and point next to head.
   Here, we don't need to explicitly handle the empty LL as head would be null by default.
   In case of inserting at end, first we create new node.Then,we need to explictly handle case of empty linked list by returning temp instead of head as head is NULL.
   Secondly,if LL contains node(s),we need to traverse till the next element is NULL and point next element to the node we created.
   Code:
      Node *insertAtBegining(Node *head, int x) {
          struct Node *temp = new Node(x);
          temp->next=head;
          return temp;
       }
       //Function to insert a node at the end of the linked list.
       Node *insertAtEnd(Node *head, int x)  {
        struct Node *temp=new Node(x);
        if(head==NULL)
        {
           return temp;
        }
        Node *curr=head;
        while(curr->next!=NULL){
            curr=curr->next;
        }
        curr->next=temp;
        return head;
       }
7.Insert in Middle of Linked List
   This is a challenging problem compared to previous ones and require some hit and trial.
   Start with creating new node struct temp with value of x.
   First,explicitly handle empty LL case as we will be using two pointer approach.
   Initialize fast pointer as head->next and slow pointer as head.
   {/*
      If we keep fast as head, then we run into touble when given LL size is even.
      Suppose, LL is 1 2 4 5 and we are given 3 to place in middle and we initialize fast as head.
      Fast will move to 4 and slow to 2 with 1 iteration left when slow will move to 4 and we get output as 1 2 4 3 5, same applicable to every even sized LL.
   */}
   Next,comes traversing to middle element of LL. While fast moves two positions,slow moves one, so when fast reaches end, slow reaches middle.
   Now, at the end of loop, we reached middle, first assign next of temp as next of slow and then assign temp as slow's next.
   Return head to get required LL.
   Code:
      Node* insertInMiddle(Node* head, int x)
      {
         struct Node *temp=new Node(x);
         if(head==NULL)
         {
             return temp;
         }
         Node *fast=head->next;
         Node *slow=head;
         while(fast!=NULL && fast->next!=NULL)
         {   
             fast=fast->next->next;
             slow=slow->next;
         }
         temp->next=slow->next;
         slow->next=temp;
         return head;
      }
      
8.Insert at given position
   If we think about solving this problem as previous one, we will end up getting segmentation fault as the function is void because we will be asking for unknown location.
   Instead of creating node first, only create at time of inserting and traveese alongwith incimenting constant till we reach desired position.
   Code:
      void insertAtPosition(Node *head, int pos, int data)
      {
          Node *curr=head;
          int p=0;
          while(curr!=NULL)
          {
              p++;
              if(p==pos)
              {
                  Node *temp=new Node(data);
                  temp->next=curr->next;
                  curr->next=temp;
                  break;
              }
              curr=curr->next;
          }
      }
9.Insert in a sorted Linked List
   This problem can be divided into 2 cases:
   1.If head is NULL or if given element is smaller than head.
   3.Inserting in middle or end.
   Initialize current node and new temp node. Check for case 1. If yes then make next of new node as head and assign current node as head.
   In case 2 then traverrse till either last node or larger value than given. Then assign new node's next as current's next and new node as current's next.
   Code:
      Node * insertInSorted(Node * head, int data)
      {
       Node *new_node = new Node(data);
         // Case 1: LL is empty OR first element is greater the new_node->value
       if(head==NULL || head->data >= data)
       {
           new_node->next=head;
           head= new_node;
           return head;
       }
       // Case 2: new node is between or at the end of the LL
       Node *current = head;
       while(current->next != NULL && current->next->data <= data)
       {
           current = current->next;
       }
       new_node ->next = current->next;
       current->next = new_node;
       return head;
      }
10.Delete Tail of Linked List
   This problem can be divided into two cases:
   1.List is empty or contain just one element. Return NULL.
   2.Start traversing from head till we reach second last element of LL.
     Delete the next node and assign next as NULL.
   Code:
     Node * deleteTail(Node *head)
      {
          if(head==NULL || head->next==NULL)
          {
              return NULL;
          }
          Node *curr=head;
          while(curr->next->next!=NULL)
          {
              curr=curr->next;
          }
          delete (curr->next);
          curr->next=NULL;
          return head;
      }
