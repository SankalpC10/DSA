Linked List is a list of chained nodes. Each node has data and a pointer which point towards next node.
struct Node
{
   int data;
   Node *next;
}


1. Display Linked List
   As vector is initialised in function, first create a vector with int type. As we don't need to modify the elements of linked list, create a new temporary node.
   Node should have data of head.We will initialize pointer while loop function. Using while loop, traverse till temp!=NULL.
   In while loop - insert the data of first node in vector and point the location to next element from linked list. Then return vector.
Code:
   vector<int> displayList(Node *head)
  {
    vector<int>v;
    Node*temp=head;
    while(temp!=NULL)
    {
        v.push_back(temp->data);
        temp=temp->next;
    }
    return v;
  }
  
2. Sum The Nodes of Linked List
  Here,we need to return an int data type. So,we begin with creating an int variable. Then create a temporrary node which points at head. Start traversing till temp!=NULL,
  while adding each data of temp to sum. Move temp pointer to next element. Return sum. 
Code:
   int sumOfElements(Node *head)
   {
      int sum=0;
      Node *temp=head;
      while(temp!=NULL)
      {
          sum+=temp->data;
          temp=temp->next;
      }
      return sum;
   }
   
3.Count nodes of linked list
   Keep a variable count and keep incrementing it by 1 till we reach last node of linked list.
  Code:
      int getCount(struct Node* head){
        int count=0;
        Node *temp=head;
        while(temp!=NULL)
        {
            count++;
            temp=temp->next;
        }
        return count;
      }
    
 4.Maximum and Minimum in Linked List
   The code is divided into two functions. The first returns maximum and second, the minimum.
   Initialize the variable max as INT_MIN and while traversing check if elements in linked list are greater than our variable and if greater,update our variable with greater value
   from LL.
   Similarly, initialize variable min as INT_Max and keep updating value if we find any smaller element in LL.
   Code:
      int maximum(Node *head)
     {
       int max=INT_MIN;
       Node *temp=head;
       while (temp!=NULL)
       {
           if(temp->data>max)
           {
               max=temp->data;
           }
           temp=temp->next;
       }
       return max;
     }

     int minimum(Node *head)
     {
       int min=INT_MAX;
       Node *temp=head;
       while (temp!=NULL)
       {
           if(temp->data<min)
           {
               min=temp->data;
           }
           temp=temp->next;
       }
       return min;
      }
      
5.Search in a LL
   The function type is boolean, so we make default return type as 0,if we are unable to find required eleent x in our LL.
   Initialize temp node and traverse till end of LL. Return 1 if we find required element.
  Code:
      bool searchLinkedList(Node *head, int x)
      {
          Node *temp=head;
          while(temp!=NULL)
          {
              if(temp->data==x)
              {
                  return 1;
              }
              temp=temp->next;
          }
          return 0;
      }
      
6.Linked List Insertion
   The problem is divide into two parts, insert at beginning and insert at the end.
   Insert in beginning is easier as we just need to create a new node temp containing value of x using struct and point next to head. Here, we don't need to explicitly handle the empty
   LL as head would be null by default.
   In case of inserting at end, first we create new node.Then,we need to explictly handle case of empty linked list by returning temp instead of head as head is NULL.
   Secondly,if LL contains node(s),we need to traverse till the next element is NULL and point next element to the node we created.
   Code:
      Node *insertAtBegining(Node *head, int x) {
          struct Node *temp = new Node(x);
          temp->next=head;
          return temp;
       }
       //Function to insert a node at the end of the linked list.
       Node *insertAtEnd(Node *head, int x)  {
        struct Node *temp=new Node(x);
        if(head==NULL)
        {
           return temp;
        }
        Node *curr=head;
        while(curr->next!=NULL){
            curr=curr->next;
        }
        curr->next=temp;
        return head;
       }
